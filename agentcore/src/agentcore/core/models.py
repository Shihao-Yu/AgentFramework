"""Core models for agent execution."""

from __future__ import annotations

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Optional

from pydantic import BaseModel, ConfigDict, Field


class StepStatus(str, Enum):
    """Status of a plan step."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class InteractionStatus(str, Enum):
    """Status of human-in-the-loop interactions."""

    AWAITING_APPROVAL = "awaiting_approval"
    APPROVED = "approved"
    REJECTED = "rejected"
    TIMED_OUT = "timed_out"


class PlanStep(BaseModel):
    """A single step in an execution plan."""

    model_config = ConfigDict(frozen=False)  # Mutable for status updates

    id: str = Field(description="Step identifier")
    description: str = Field(description="What this step does")
    sub_agent: str = Field(description="Which sub-agent handles this (planner, researcher, analyzer, executor, synthesizer)")
    instruction: str = Field(description="Detailed instruction for the sub-agent")
    
    # Execution state
    status: StepStatus = Field(default=StepStatus.PENDING)
    result: Optional[Any] = Field(default=None, description="Step result")
    error: Optional[str] = Field(default=None, description="Error if failed")
    
    # Dependencies
    depends_on: list[str] = Field(default_factory=list, description="Step IDs this depends on")
    
    # Timing
    started_at: Optional[datetime] = Field(default=None)
    completed_at: Optional[datetime] = Field(default=None)

    def start(self) -> None:
        """Mark step as started."""
        self.status = StepStatus.IN_PROGRESS
        self.started_at = datetime.now(timezone.utc)

    def complete(self, result: Any = None) -> None:
        """Mark step as completed."""
        self.status = StepStatus.COMPLETED
        self.result = result
        self.completed_at = datetime.now(timezone.utc)

    def fail(self, error: str) -> None:
        """Mark step as failed."""
        self.status = StepStatus.FAILED
        self.error = error
        self.completed_at = datetime.now(timezone.utc)

    def skip(self, reason: str = "Skipped") -> None:
        """Mark step as skipped."""
        self.status = StepStatus.SKIPPED
        self.error = reason
        self.completed_at = datetime.now(timezone.utc)

    @property
    def duration_ms(self) -> Optional[float]:
        """Get step duration in milliseconds."""
        if self.started_at is None or self.completed_at is None:
            return None
        return (self.completed_at - self.started_at).total_seconds() * 1000


class ExecutionPlan(BaseModel):
    """Execution plan generated by the Planner."""

    model_config = ConfigDict(frozen=False)

    query: str = Field(description="Original user query")
    goal: str = Field(description="High-level goal")
    steps: list[PlanStep] = Field(default_factory=list)
    
    # Plan metadata
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    version: int = Field(default=1, description="Plan version (increments on replan)")
    
    # Completion
    is_complete: bool = Field(default=False)
    final_result: Optional[str] = Field(default=None)

    @property
    def current_step(self) -> Optional[PlanStep]:
        """Get the current in-progress or next pending step."""
        for step in self.steps:
            if step.status == StepStatus.IN_PROGRESS:
                return step
        for step in self.steps:
            if step.status == StepStatus.PENDING:
                # Check dependencies are met
                if self._dependencies_met(step):
                    return step
        return None

    @property
    def completed_steps(self) -> list[PlanStep]:
        """Get all completed steps."""
        return [s for s in self.steps if s.status == StepStatus.COMPLETED]

    @property
    def failed_steps(self) -> list[PlanStep]:
        """Get all failed steps."""
        return [s for s in self.steps if s.status == StepStatus.FAILED]

    @property
    def progress_percent(self) -> float:
        """Get completion percentage."""
        if not self.steps:
            return 0.0
        completed = len([s for s in self.steps if s.status in (StepStatus.COMPLETED, StepStatus.SKIPPED)])
        return (completed / len(self.steps)) * 100

    def _dependencies_met(self, step: PlanStep) -> bool:
        """Check if step dependencies are satisfied."""
        if not step.depends_on:
            return True
        
        step_map = {s.id: s for s in self.steps}
        for dep_id in step.depends_on:
            dep = step_map.get(dep_id)
            if dep is None or dep.status not in (StepStatus.COMPLETED, StepStatus.SKIPPED):
                return False
        return True

    def get_step(self, step_id: str) -> Optional[PlanStep]:
        """Get step by ID."""
        for step in self.steps:
            if step.id == step_id:
                return step
        return None

    def add_step(self, step: PlanStep) -> None:
        """Add a step to the plan."""
        self.steps.append(step)

    def replan(self, new_steps: list[PlanStep]) -> None:
        """Replace remaining pending steps with new ones."""
        # Keep completed and in-progress steps
        kept = [s for s in self.steps if s.status in (StepStatus.COMPLETED, StepStatus.IN_PROGRESS)]
        kept.extend(new_steps)
        self.steps = kept
        self.version += 1


class SubAgentResult(BaseModel):
    """Result from a sub-agent execution."""

    model_config = ConfigDict(frozen=True)

    success: bool = Field(description="Whether execution succeeded")
    output: Any = Field(description="Output data")
    error: Optional[str] = Field(default=None, description="Error message if failed")
    
    # Metrics
    tokens_used: int = Field(default=0)
    duration_ms: float = Field(default=0.0)
    
    # Replanning signals
    replan_needed: bool = Field(default=False, description="Whether plan needs revision")
    replan_reason: Optional[str] = Field(default=None, description="Why replan is needed")

    @classmethod
    def success_result(cls, output: Any, tokens_used: int = 0, duration_ms: float = 0.0) -> "SubAgentResult":
        """Create a successful result."""
        return cls(
            success=True,
            output=output,
            tokens_used=tokens_used,
            duration_ms=duration_ms,
        )

    @classmethod
    def failure_result(cls, error: str, duration_ms: float = 0.0) -> "SubAgentResult":
        """Create a failed result."""
        return cls(
            success=False,
            output=None,
            error=error,
            duration_ms=duration_ms,
        )

    @classmethod
    def replan_result(cls, reason: str, output: Any = None) -> "SubAgentResult":
        """Create a result that triggers replanning."""
        return cls(
            success=True,
            output=output,
            replan_needed=True,
            replan_reason=reason,
        )


class ToolResult(BaseModel):
    """Result from a tool execution."""

    model_config = ConfigDict(frozen=True)

    tool_call_id: str = Field(description="ID of the tool call")
    tool_name: str = Field(description="Name of the tool")
    
    # Result
    success: bool = Field(default=True)
    result: Any = Field(description="Tool output")
    compact_result: Optional[Any] = Field(default=None, description="Compacted result for context management")
    error: Optional[str] = Field(default=None, description="Error if failed")
    
    # Timing
    duration_ms: float = Field(default=0.0)

    @classmethod
    def success_result(
        cls,
        tool_call_id: str,
        tool_name: str,
        result: Any,
        compact_result: Optional[Any] = None,
        duration_ms: float = 0.0,
    ) -> "ToolResult":
        """Create a successful tool result."""
        return cls(
            tool_call_id=tool_call_id,
            tool_name=tool_name,
            success=True,
            result=result,
            compact_result=compact_result,
            duration_ms=duration_ms,
        )

    @classmethod
    def failure_result(
        cls,
        tool_call_id: str,
        tool_name: str,
        error: str,
        duration_ms: float = 0.0,
    ) -> "ToolResult":
        """Create a failed tool result."""
        return cls(
            tool_call_id=tool_call_id,
            tool_name=tool_name,
            success=False,
            result=None,
            error=error,
            duration_ms=duration_ms,
        )

    def get_result_for_context(self) -> Any:
        """Get the result to use in LLM context (compact if available)."""
        return self.compact_result if self.compact_result is not None else self.result


class AgentState(str, Enum):
    """State of the agent during execution."""

    IDLE = "idle"
    PLANNING = "planning"
    RESEARCHING = "researching"
    ANALYZING = "analyzing"
    EXECUTING = "executing"
    SYNTHESIZING = "synthesizing"
    WAITING_FOR_INPUT = "waiting_for_input"  # HIL
    COMPLETED = "completed"
    FAILED = "failed"
